<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<title>PYTHON</title>
</head>
<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}

	body {
		background-color: #263238;
		overflow: hidden;
		color: #e0e0e0;
		font-family: monospace;
		font-size: 20px;
		line-height: 2.5;
		height: 100vh;
	}

	.content {
		position: relative;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: fit-content;
	}

	canvas {
		background-color: #263238;
		width: 300px;
		height: 400px;
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
	}

	button {
		padding: 15px 30px;
		font-size: 24px;
		color: white;
		text-shadow: 2px 4px 2px #000;
		background-color: #4CAF50;
		border: none;
		border-radius: 30px;
		cursor: pointer;
	}

	.btn {
		display: block;
		margin: 0 auto;
		margin-top: 50px;
		width: fit-content;
	}

	.s-btn {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
	}

	.hidden {
		display: none;
	}

	ul {
		list-style: none;
		margin: 0;
		padding: 0;
	}

	.a {
		padding: 60px;
		border-radius: 15px;
		width: 100%;
	}

	.c {
		color: gold;
	}

	.s {
		margin-top: 50px;
		filter: blur(5px);
		border: 1px solid gold;
		width: fit-content;
		padding: 10px 20px;
		border-radius: 10px;
		cursor: progress;
		transition: 1s;
	}

	.s:hover {
		filter: blur(0);
	}

	.c1 {
		position: relative;
	}

	.c1::before {
		content: '0 1 2';
		position: absolute;
		width: 100px;
		height: 20px;
		top: -50px;
		left: 13px;
		letter-spacing: 5.5px;
		color: gray;
	}
</style>

<body>
	<canvas id="gameCanvas" width="300" height="400"></canvas>
	<button class="s-btn" id="startButton">
		START
	</button>
	<main class="content hidden">
		<div class="a" id="block1">
			<div><span class="c">for</span> a <span class="c">in</span> 5,4,3,2,1,'hi'<span class="c">:</span></div>
			<div>&nbsp;<span class="c">print</span>(a)</div>
			<div class="s">5 4 3 2 1 hi</div>
			<button class="btn">Далее</button>
		</div>

		<div class="a hidden" id="block2">
			<div>print(<span class="c c1">[</span>1, 2, 3<span class="c">][2]</span>)</div>
			<div class="s">3</div>
			<button class="btn">Далее</button>
		</div>

		<div class="a hidden" id="block3">
			<div>a = {</div>
			<div>'a': '1',</div>
			<div>'b': '2'</div>
			<div>}</div>
			<div>print(<span class="c">a['b']</span>)</div>
			<div class="s">2</div>
		</div>
	</main>

	<script>
		const canvas = document.getElementById('gameCanvas');
		const ctx = canvas.getContext('2d');
		const startButton = document.getElementById('startButton');
		const content = document.querySelector('.content');

		let currentBlock = 0; // Начальный блок, который показывается
		const blocks = document.querySelectorAll('.a'); // Все блоки с классом 'a'
		const buttons = document.querySelectorAll('.btn'); // Все кнопки "Далее"

		const box = 25; // размер клетки
		let snake;
		let food;
		let direction; // текущее направление
		let game;

		function resetGame() {
			snake = [{
				x: 4 * box,
				y: 4 * box
			}];
			food = {
				x: Math.floor(Math.random() * (canvas.width / box)) * box,
				y: Math.floor(Math.random() * (canvas.height / box)) * box
			};
			direction = 'RIGHT'; // начальное направление
			clearInterval(game); // Останавливаем предыдущую игру
			game = setInterval(draw, 100); // Запускаем игру заново
		}

		function draw() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Рисуем змею
			for (let i = 0; i < snake.length; i++) {
				ctx.beginPath();
				ctx.arc(snake[i].x + box / 2, snake[i].y + box / 2, box / 2, 0, Math.PI * 1.8); // Используем arc для круга
				ctx.fillStyle = (i === 0) ? 'green' : 'lightgreen';
				ctx.fill();
				ctx.strokeStyle = 'darkgreen';
				ctx.stroke();
			}

			// Рисуем еду
			ctx.fillStyle = 'red';
			ctx.fillRect(food.x, food.y, box, box);

			// Логика движения змейки
			let snakeX = snake[0].x;
			let snakeY = snake[0].y;

			if (direction === 'LEFT') snakeX -= box;
			if (direction === 'UP') snakeY -= box;
			if (direction === 'RIGHT') snakeX += box;
			if (direction === 'DOWN') snakeY += box;

			// Проверка на сбитие с едой
			if (snakeX === food.x && snakeY === food.y) {
				// Создаем новую еду в случайном месте
				food = {
					x: Math.floor(Math.random() * (canvas.width / box)) * box,
					y: Math.floor(Math.random() * (canvas.height / box)) * box
				};
			} else {
				snake.pop(); // Удаляем последний сегмент змейки
			}

			// Обработка выхода за границы
			snakeX = (snakeX + canvas.width) % canvas.width;
			snakeY = (snakeY + canvas.height) % canvas.height;

			const newHead = {
				x: snakeX,
				y: snakeY
			};

			// Проверка на столкновение со своим телом
			if (collide(newHead, snake)) {
				resetGame(); // Перезагружаем игру
				return; // Выход из функции, чтобы не добавлять новую голову
			}

			snake.unshift(newHead); // Добавляем новую голову
			autoDirection(newHead); // Вызываем функцию для изменения направления
		}

		function collide(head, array) {
			for (let i = 1; i < array.length; i++) { // Начинаем с 1, чтобы не проверять голову
				if (array[i].x === head.x && array[i].y === head.y) {
					return true;
				}
			}
			return false;
		}

		function autoDirection(snakeHead) {
			// Логика самоуправления: поворачиваем к еде
			if (snakeHead.x < food.x) direction = 'RIGHT';
			else if (snakeHead.x > food.x) direction = 'LEFT';
			else if (snakeHead.y < food.y) direction = 'DOWN';
			else if (snakeHead.y > food.y) direction = 'UP';
		}

		// Обработчик события кнопки "START"
		startButton.addEventListener('click', () => {
			canvas.classList.add('hidden'); // Скрываем canvas
			startButton.classList.add('hidden'); // Скрываем кнопку
			resetGame(); // Запускаем игру
			content.classList.remove('hidden')
		});

		// Инициализация первой игры
		resetGame();
		buttons.forEach(button => {
			button.addEventListener('click', () => {
				if (currentBlock < blocks.length - 1) { // Проверяем, есть ли следующий блок
					blocks[currentBlock].classList.add('hidden'); // Скрываем текущий блок
					currentBlock++; // Переходим к следующему блоку
					blocks[currentBlock].classList.remove('hidden'); // Показываем новый блок
				}
			});
		});
	</script>
</body></html>
