Основы C/C++: Понимание уязвимостей
Языки C и C++ дают программистам низкоуровневый контроль над памятью и системными ресурсами, но это также делает их источником многих уязвимостей, если код написан неосторожно.

1. Типичные уязвимости в C/C++
1.1. Переполнение буфера (Buffer Overflow)
Что это: Запись данных за пределы выделенной памяти (стек или куча).

char buffer[10];  
strcpy(buffer, "This string is too long!"); // Переполнение

Перезапись соседних переменных.
Возможность выполнения произвольного кода (например, через перезапись адреса возврата).

Использование безопасных функций (strncpy, snprintf).
Инструменты: ASLR (рандомизация адресов), Stack Canaries.

1.2. Уязвимости форматных строк (Format String)
Что это: Неправильное использование printf, sprintf и подобных функций.
Пример:

char user_input[100];  
scanf("%s", user_input);  
printf(user_input); // Опасность, если ввод содержит %x, %n  
Последствия:

Чтение/запись в произвольные участки памяти.
Возможность выполнения кода.

Всегда использовать статическую строку формата:
printf("%s", user_input); // Безопасно  

1.3. Разыменование нулевого указателя (NULL Pointer Dereference)
Что это: Попытка доступа к памяти по адресу NULL.

int *ptr = NULL;  
*ptr = 10; // Segmentation fault  
Последствия:

Аварийное завершение программы (DoS).
В некоторых системах – возможность эксплуатации.

Проверка указателей перед использованием.

1.4. Утечки памяти (Memory Leaks) Неосвобождённая динамическая память.

void leak() {  
    int *arr = malloc(100 * sizeof(int));  
    // Забыли free(arr);  
}  

Постепенное исчерпание памяти.

Использование free() для каждого malloc().
Инструменты: Valgrind, AddressSanitizer.

1.5. Целочисленные переполнения (Integer Overflow)
Что это: Превышение максимального значения типа.

int a = INT_MAX;  
int b = a + 1; // Переполнение (undefined behavior)  

Непредсказуемое поведение программы.
Возможны уязвимости в алгоритмах проверки размеров.

Проверка границ перед операциями.
Использование uint32_t, size_t вместо int там, где важно.

1.6. Use-After-Free (UAF)
Что это: Использование памяти после её освобождения.

int *ptr = malloc(sizeof(int));  
free(ptr);  
*ptr = 10; // Опасность!  
Последствия:

Повреждение данных кучи.
Возможность выполнения кода.

Обнуление указателей после free().
Использование умных указателей (std::unique_ptr в C++).

2. Уязвимости, связанные с C++
2.1. Небезопасное приведение типов (Unsafe Casting)

cpp
class Base { virtual void foo() {} };  
class Derived : public Base { int secret; };  

Base *b = new Base();  
Derived *d = static_cast<Derived*>(b); // Опасное приведение  
Последствия:

Доступ к несуществующим полям.

Использование dynamic_cast (проверяет тип во время выполнения).

2.2. Переполнение вектора (Vector Overflow)

cpp
std::vector<int> v;  
v.reserve(10);  
v[15] = 42; // Неопределённое поведение  

Использование v.at(15) (бросает исключение).

3. Инструменты для поиска уязвимостей
Статические анализаторы:
Cppcheck – поиск ошибок в коде.
Clang Static Analyzer – встроен в Clang/LLVM.
Динамические анализаторы:
Valgrind – поиск утечек памяти.
AddressSanitizer (ASan) – обнаружение переполнений буфера.
Фаззеры:
AFL (American Fuzzy Lop) – поиск уязвимостей через случайные входные данные.

4. Лучшие практики безопасного кода
✅ Используйте безопасные функции:

snprintf вместо sprintf.

std::string вместо char[] в C++.
✅ Включайте предупреждения компилятора:

bash
gcc -Wall -Wextra -Werror program.c  
✅ Пишите модульные тесты (например, Google Test для C++).
✅ Применяйте принцип минимальных привилегий – не используйте root без необходимости.

5. Примеры эксплуатации уязвимостей
5.1. Эксплуатация переполнения буфера
c
#include <string.h>  

void vulnerable() {  
    char buffer[10];  
    gets(buffer); // Опасная функция!  
}  

int main() {  
    vulnerable();  
    return 0;  
}  
Как эксплуатировать:

Передать строку длиннее 10 символов, чтобы перезаписать адрес возврата.

5.2. Use-After-Free в C++
cpp
#include <memory>  

int main() {  
    int *ptr = new int(42);  
    delete ptr;  
    *ptr = 100; // Use-After-Free  
    return 0;  
} 