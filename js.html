<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>JavaScript Справочник</title>
	<style>
		:root {
			--bg-color: #1e1e2e;
			--text-color: #e0e0e0;
			--primary-color: #bb86fc;
			--secondary-color: #03dac6;
			--border-color: #44475a;
			--table-header-bg: #2d2d3d;
			--code-bg: #282a36;
			--hover-color: #383a59;
		}

		body {
			background: var(--bg-color);
			color: var(--text-color);
			font-family: 'Fira Code', 'Consolas', monospace;
			font-size: 16px;
			line-height: 1.6;
			padding: 20px;
			max-width: 1200px;
			margin: 0 auto;
		}

		h1,
		h2,
		h3 {
			color: var(--primary-color);
			margin-top: 30px;
			border-bottom: 1px solid var(--border-color);
			padding-bottom: 10px;
		}

		h2 {
			color: var(--secondary-color);
			font-size: 1.8em;
			margin-top: 40px;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			margin: 25px 0;
			box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
			border-radius: 8px;
			overflow: hidden;
		}

		table th,
		table td {
			padding: 15px 20px;
			text-align: left;
			border: 1px solid var(--border-color);
		}

		table th {
			background-color: var(--table-header-bg);
			color: var(--primary-color);
			font-weight: bold;
			text-transform: uppercase;
			font-size: 0.9em;
			letter-spacing: 0.5px;
		}

		table tr:nth-child(even) {
			background-color: rgba(68, 71, 90, 0.2);
		}

		table tr:hover {
			background-color: var(--hover-color);
		}

		pre,
		code {
			font-family: 'Fira Code', 'Consolas', monospace;
			background: var(--code-bg);
			color: #f8f8f2;
			padding: 10px;
			border-radius: 5px;
			overflow-x: auto;
			tab-size: 2;
			margin: 0;
		}

		pre {
			white-space: pre-wrap;
			word-wrap: break-word;
		}

		code {
			padding: 2px 5px;
		}

		ul {
			margin: 0;
			padding: 0;
			list-style: none;
		}

		ul li {
			padding: 3px 0;
		}

		ul li:before {
			content: "•";
			color: var(--secondary-color);
			display: inline-block;
			width: 1em;
			margin-left: -1em;
		}

		.keyword {
			color: #ff79c6;
			font-weight: bold;
		}

		.string {
			color: #f1fa8c;
		}

		.comment {
			color: #6272a4;
			font-style: italic;
		}

		.number {
			color: #bd93f9;
		}

		.operator {
			color: #ff5555;
		}

		.function {
			color: #50fa7b;
		}

		@media (max-width: 768px) {
			body {
				padding: 10px;
				font-size: 14px;
			}

			table th,
			table td {
				padding: 10px 12px;
			}

			h2 {
				font-size: 1.5em;
			}
		}

	</style>
</head>

<body>
	<h1>Javascript</h1>
	<h2>Base</h2>
	<table>
		<tr>
			<td>тег для работы кода js</td>
			<td>&#60;script></td>
		</tr>

		<tr>
			<td>типы скриптов</td>
			<td>type="text/javascript"</td>
		</tr>

		<tr>
			<td>внешние скрипты</td>
			<td>src="/path/to/script.js"</td>
		</tr>

		<tr>
			<td>вызов окна в браузере с предупреждением</td>
			<td>alert</td>
		</tr>

		<tr>
			<td>вызов окна с вопросом
				(Окно ОК ОТМЕНА)</td>
			<td>prompt</td>
		</tr>

		<tr>
			<td>вызов окна с подтвеждением
				(ОК ОТМЕНА)</td>
			<td>confirm</td>
		</tr>

		<tr>
			<td>комментарии</td>
			<td>// /* */</td>
		</tr>

		<tr>
			<td>строгий режим для устранения ошибок</td>
			<td>'use strict'</td>
		</tr>

		<tr>
			<td>консоль браузера</td>
			<td>F12</td>
		</tr>

		<tr>
			<td>переменные</td>
			<td>let const</td>
		</tr>

		<tr>
			<td>правильные имена переменных
			</td>
			<td>a z A Z 0 9 $ _</td>
		</tr>

		<tr>
			<td>типы данных</td>
			<td>
				<ul>
					<li>числа</li>
					<li>bigint</li>
					<li>числа с плавающей точкой</li>
					<li>NaN</li>
					<li>null</li>
					<li>undefined</li>
					<li>[]</li>
					<li>{}</li>
					<li>Symbol</li>
					<li>true false</li>
					<li>string</li>
					<li>typeof</li>
				</ul>
			</td>
		</tr>

		<tr>
			<td>перевод данных в строку, число, Boolean</td>
			<td>+ Number Boolean String</td>
		</tr>

		<tr>
			<td>операции</td>
			<td>
				<ul>
					<li>+ сложение</li>
					<li>- вычитание</li>
					<li>* умножение</li>
					<li>** возведение в степень</li>
					<li>% получение остатка</li>
					<li>++a инкремент</li>
					<li>a++ декремент</li>
				</ul>
			</td>
		</tr>

		<tr>
			<td>Побитовы операторы</td>
			<td>&#38; | ^ ~ <<>> >>></td>
		</tr>

		<tr>
			<td>Сравнение</td>
			<td>
				<=>= == === != !==
			</td>
		</tr>

		<tr>
			<td>условие
				несколько условий
				иначе</td>
			<td>if else if else</td>
		</tr>

		<tr>
			<td>тернарный</td>
			<td>усл ? true : false</td>
		</tr>

		<tr>
			<td>логика</td>
			<td>|| ||= &#38;&#38; &#38;&#38;= ! ?? ??=</td>
		</tr>

		<tr>
			<td>циклы</td>
			<td>while, do..while и for(..;..;..)</td>
		</tr>

		<tr>
			<td>кейсы</td>
			<td>switch() {case:}</td>
		</tr>
	</table>

	<h2>Функции</h2>
	<table>
		<tr>
			<td>Создание функции</td>
			<td>let func = new Function([arg1, arg2, ...argN], functionBody);</td>
		</tr>
		<tr>
			<td>локальные переменные</td>
			<td>
				<pre>
function greet() {
    const message = "Hello!"; 
    
    // Локальная переменная
    console.log(message);
}
greet(); // "Hello!"
// console.log(message); 
// Ошибка: message не определена
</pre>
			</td>
		</tr>
		<tr>
			<td>параметры</td>
			<td>
				<pre>
function sum(a, b) { // a и b — параметры
    return a + b;
}
console.log(sum(2, 3)); // 5
</pre>
			</td>
		</tr>

		<tr>
			<td>параметры по умолчанию</td>
			<td>
				<pre>
function greet(name = "Guest") {
    console.log(`Hello, ${name}!`);
}
greet(); // "Hello, Guest!"
greet("Alice"); // "Hello, Alice!"
</pre>
			</td>
		</tr>

		<tr>
			<td>возврат значения</td>
			<td>
				<pre>
function multiply(a, b) {
    return a * b; 
    // Возврат значения
}
const result = multiply(4, 5);
console.log(result); // 20
</pre>
			</td>
		</tr>

		<tr>
			<td>неименованная функция</td>
			<td>
				<pre>
const square = function(x) { 
   // Функция без имени
    return x * x;
};
console.log(square(4)); // 16
</pre>
			</td>
		</tr>
		<tr>
			<td>именованная функция</td>
			<td>
				<pre>

function factorial(n) { 
   // Именованная функция
    if (n &#60;= 1) return 1;
    return n * factorial(n - 1);
}
console.log(factorial(5)); // 120
</pre>
			</td>
		</tr>

		<tr>
			<td>стрелочные функции</td>
			<td>() => {}</td>
		</tr>

		<tr>
			<td>области видимости и замыкание</td>
			<td>
				<pre>
function outer() {
    const outerVar = "I'm outside!";
    function inner() { 
       // Замыкание (видит outerVar)
        console.log(outerVar); // "I'm outside!"
    }
    return inner;
}
const closureFunc = outer();
closureFunc();
</pre>
			</td>
		</tr>

		<tr>
			<td>рекурсия и стек</td>
			<td>
				<pre>
function countdown(n) { // Рекурсивная функция
    if (n &#60;= 0) {
        console.log("Done!");
        return;
    }
    console.log(n);
    countdown(n - 1); // Рекурсивный вызов
}
countdown(3);
// Вывод:
// 3
// 2
// 1
// Done!
</pre>
			</td>
		</tr>
		<tr>
			<td>Свойство «name»</td>
			<td>function sayHi() {
				alert("Hi");
				}

				alert(sayHi.name); // sayHi</td>
		</tr>
		<tr>
			<td>Свойство «length»</td>
			<td>function f1(a) {}
				function f2(a, b) {}

				alert(f1.length); // 1
				alert(f2.length); // 2</td>
		</tr>
		<tr>
			<td>Привязка контекста к функции</td>
			<td>bind</td>
		</tr>
	</table>

	<h2>объекты</h2>
	<table>
		<tr>
			<td>ключи и значения</td>
			<td>
				<pre>
const obj = { name: 'John', age: 30 };
</pre>
			</td>
		</tr>
		<tr>
			<td>доступ к ключам и значениям</td>
			<td>
				<pre>
console.log(obj.name); // 'John'
console.log(obj['age']); // 30
</pre>
			</td>
		</tr>
		<tr>
			<td>вычисляемые свойства</td>
			<td>
				<pre>
const prop = 'language';
const user = { [prop]: 'JavaScript' };
console.log(user.language); // 'JavaScript'
</pre>
			</td>
		</tr>
		<tr>
			<td>проверка существования свойства</td>
			<td>
				<pre>
console.log('name' in obj); // true
console.log(obj.hasOwnProperty('age')); // true
</pre>
			</td>
		</tr>
		<tr>
			<td>цикл по ключам</td>
			<td>
				<pre>
for (const key in obj) {
  console.log(key, obj[key]);
}
</pre>
			</td>
		</tr>
		<tr>
			<td>упорядочение свойств объекта</td>
			<td>
				<pre>
const codes = { 49: 'Germany', 41: 'Switzerland', 1: 'USA' };
// Числовые ключи сортируются, строковые - в порядке добавления
</pre>
			</td>
		</tr>
		<tr>
			<td>копирование по ссылке</td>
			<td>
				<pre>
const obj2 = obj;
obj2.name = 'Alice';
console.log(obj.name); // 'Alice'
</pre>
			</td>
		</tr>
		<tr>
			<td>клонирование объекта</td>
			<td>
				<pre>
const clone = Object.assign({}, obj);
const deepClone = JSON.parse(JSON.stringify(obj));
</pre>
			</td>
		</tr>
		<tr>
			<td>сборка мусора</td>
			<td>
				<pre>
let obj = { data: '...' };
obj = null; // Объект может быть удален сборщиком мусора
</pre>
			</td>
		</tr>
		<tr>
			<td>методы</td>
			<td>
				<pre>
const user = {
  name: 'John',
  greet() { console.log(`Hello, ${this.name}!`); }
};
user.greet(); // Hello, John!
</pre>
			</td>
		</tr>
		<tr>
			<td>this</td>
			<td>
				<pre>
function User(name) { this.name = name; }
const user = new User('John');
</pre>
			</td>
		</tr>
		<tr>
			<td>конструктор new</td>
			<td>
				<pre>
function User(name) { this.name = name; }
const user = new User('John');
</pre>
			</td>
		</tr>
		<tr>
			<td>проверка создания объекта</td>
			<td>
				<pre>
function User() { console.log(new.target); }
new User(); // [Function: User]
</pre>
			</td>
		</tr>
		<tr>
			<td>опциональная цепочка</td>
			<td>
				<pre>
console.log(user?.address?.street); // undefined вместо ошибки
</pre>
			</td>
		</tr>
		<tr>
			<td>перебор ключей значений и пар</td>
			<td>
				<pre>
Object.keys(obj);    // ['name', 'age']
Object.values(obj);  // ['John', 30]
Object.entries(obj); // [['name', 'John'], ['age', 30]]
</pre>
			</td>
		</tr>
		<tr>
			<td>деструктуризация</td>
			<td>
				<pre>
const { name, age } = obj;
console.log(name, age); // John 30
</pre>
			</td>
		</tr>
		<tr>
			<td>оператор расширения</td>
			<td>
				<pre>
const newObj = { ...obj, city: 'Paris' };
</pre>
			</td>
		</tr>
		<tr>
			<td>Флаги свойств</td>
			<td>
				<pre>
Object.getOwnPropertyDescriptor(obj, 'name');
// { value: 'John', writable: true, enumerable: true, configurable: true }
</pre>
			</td>
		</tr>
		<tr>
			<td>геттеры и сеттеры</td>
			<td>
				<pre>
const user = {
  _name: 'John',
  get name() { return this._name; },
  set name(value) { this._name = value; }
};
</pre>
			</td>
		</tr>
	</table>
	<h2>Symbol</h2>
	<table>
		<tr>
			<td>скрытые свойства</td>
			<td>
				<pre><code>const id = Symbol('id');
const user = {
  name: 'John',
  [id]: 123 // Скрытое свойство
};
console.log(user[id]); // 123</code></pre>
			</td>
		</tr>
		<tr>
			<td>символ в объекте</td>
			<td>
				<pre><code>const id = Symbol('id');
const obj = {
  [id]: 'symbol value',
  name: 'Object'
};
console.log(obj[id]); // 'symbol value'</code></pre>
			</td>
		</tr>
		<tr>
			<td>не в цикле</td>
			<td>
				<pre><code>const id = Symbol('id');
const obj = {
  [id]: 'hidden',
  name: 'Visible'
};

for (let key in obj) {
  console.log(key); // только 'name'
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>глобальные символы</td>
			<td>
				<pre><code>// Создание/получение глобального символа
const globalSym = Symbol.for('global');
console.log(Symbol.keyFor(globalSym)); // 'global'

// Проверка
const sameSym = Symbol.for('global');
console.log(globalSym === sameSym); // true</code></pre>
			</td>
		</tr>
		<tr>
			<td>ключ по символам</td>
			<td>
				<pre><code>const sym = Symbol('key');
const obj = {
  [sym]: 'value',
  name: 'Object'
};

const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // [Symbol(key)]</code></pre>
			</td>
		</tr>
	</table>

	<h2>Числа</h2>
	<table>
		<tr>
			<td>сокращенная запись нулей</td>
			<td>
				<pre><code>const billion = 1e9; // 1 000 000 000
const micro = 1e-6; // 0.000001
console.log(billion); // 1000000000</code></pre>
			</td>
		</tr>
		<tr>
			<td>двоичная восьмеричная шестнадцатиричная</td>
			<td>
				<pre><code>const binary = 0b11111111; // 255
const octal = 0o377; // 255
const hex = 0xff; // 255
console.log(binary, octal, hex); // 255 255 255</code></pre>
			</td>
		</tr>
		<tr>
			<td>перевод в строку</td>
			<td>
				<pre><code>const num = 255;
console.log(num.toString(16)); // 'ff'
console.log(num.toString(2)); // '11111111'
console.log(String(num)); // '255'</code></pre>
			</td>
		</tr>
		<tr>
			<td>округление чисел</td>
			<td>
				<pre><code>console.log(Math.floor(3.9)); // 3 (вниз)
console.log(Math.ceil(3.1)); // 4 (вверх)
console.log(Math.round(3.5)); // 4 (к ближайшему)
console.log(Math.trunc(3.9)); // 3 (отбросить дробную часть)</code></pre>
			</td>
		</tr>
		<tr>
			<td>бесконечность</td>
			<td>
				<pre><code>console.log(1 / 0); // Infinity
console.log(-1 / 0); // -Infinity
console.log(Number.POSITIVE_INFINITY); // Infinity
console.log(isFinite(1 / 0)); // false</code></pre>
			</td>
		</tr>
		<tr>
			<td>ошибки</td>
			<td>
				<pre><code>console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004</code></pre>
			</td>
		</tr>
		<tr>
			<td>убрать нужно количество после точки и округлить</td>
			<td>
				<pre><code>const num = 12.34567;
console.log(num.toFixed(2)); // "12.35" (строка)
console.log(+num.toFixed(2)); // 12.35 (число)</code></pre>
			</td>
		</tr>
		<tr>
			<td>проверка на не число</td>
			<td>
				<pre><code>console.log(isNaN(NaN)); // true
console.log(isNaN("строка")); // true
console.log(Number.isNaN("строка")); // false</code></pre>
			</td>
		</tr>
		<tr>
			<td>проверка на число</td>
			<td>
				<pre><code>console.log(isFinite("123")); // true
console.log(isFinite("строка")); // false
console.log(Number.isInteger(123.0)); // true</code></pre>
			</td>
		</tr>
		<tr>
			<td>убрать все кроме целого числа</td>
			<td>
				<pre><code>console.log(parseInt("100px")); // 100
console.log(parseInt("12.3")); // 12
console.log(Math.trunc(12.3)); // 12</code></pre>
			</td>
		</tr>
		<tr>
			<td>убрать все кроме числа с точкой</td>
			<td>
				<pre><code>console.log(parseFloat("12.3em")); // 12.3
console.log(parseFloat("12.3.4")); // 12.3</code></pre>
			</td>
		</tr>
		<tr>
			<td>рандом</td>
			<td>
				<pre><code>console.log(Math.random()); // случайное число от 0 до 1
// Функция для получения случайного числа в диапазоне
function random(min, max) {
  return min + Math.random() * (max - min);
}</code></pre>
			</td>
		</tr>
		<tr>
			<td>максимальное</td>
			<td>
				<pre><code>console.log(Math.max(3, 5, 1)); // 5
console.log(Math.max(...[3, 5, 1])); // 5 (с spread оператором)</code></pre>
			</td>
		</tr>
		<tr>
			<td>минимальное</td>
			<td>
				<pre><code>console.log(Math.min(3, 5, 1)); // 1
console.log(Math.min(...[3, 5, 1])); // 1 (с spread оператором)</code></pre>
			</td>
		</tr>
		<tr>
			<td>в степень</td>
			<td>
				<pre><code>console.log(2 ** 3); // 8
console.log(Math.pow(2, 3)); // 8</code></pre>
			</td>
		</tr>
	</table>

	<h2>Строки</h2>
	<table>
		<tr>
			<td>сложение строк</td>
			<td>
				<pre><code>const str1 = 'Hello';
const str2 = 'World';
console.log(str1 + ' ' + str2); // 'Hello World'
console.log(`${str1} ${str2}`); // 'Hello World' (шаблонные строки)</code></pre>
			</td>
		</tr>
		<tr>
			<td>типы строк</td>
			<td>
				<pre><code>const single = 'одинарные кавычки';
const double = "двойные кавычки";
const backticks = `обратные кавычки ${single}`;
console.log(backticks); // 'обратные кавычки одинарные кавычки'</code></pre>
			</td>
		</tr>
		<tr>
			<td>спецсимволы перенос табуляция</td>
			<td>
				<pre><code>console.log("Первая строка\nВторая строка");
console.log("1\t2\t3");
console.log("Экранирование: \\ \"");</code></pre>
			</td>
		</tr>
		<tr>
			<td>обращение к символам строки</td>
			<td>
				<pre><code>const str = 'Hello';
console.log(str[0]); // 'H'
console.log(str.charAt(1)); // 'e'
console.log(str.at(-1)); // 'o' (последний символ)</code></pre>
			</td>
		</tr>
		<tr>
			<td>неизменяемость строк</td>
			<td>
				<pre><code>let str = 'Hi';
str[0] = 'h'; // Ошибки нет, но строка не изменится
console.log(str); // 'Hi'</code></pre>
			</td>
		</tr>
		<tr>
			<td>изменение регистра</td>
			<td>
				<pre><code>console.log('Интерфейс'.toUpperCase()); // 'ИНТЕРФЕЙС'
console.log('Интерфейс'.toLowerCase()); // 'интерфейс'</code></pre>
			</td>
		</tr>
		<tr>
			<td>поиск подстроки</td>
			<td>
				<pre><code>const str = 'Widget with id';
console.log(str.indexOf('Widget')); // 0
console.log(str.indexOf('id')); // 1
console.log(str.lastIndexOf('id')); // 12</code></pre>
			</td>
		</tr>
		<tr>
			<td>проверка наличия в строке</td>
			<td>
				<pre><code>const str = 'Hello world';
console.log(str.includes('world')); // true
console.log(str.includes('word')); // false</code></pre>
			</td>
		</tr>
		<tr>
			<td>проверка начала и окончания</td>
			<td>
				<pre><code>const str = 'Hello world';
console.log(str.startsWith('Hello')); // true
console.log(str.endsWith('world')); // true</code></pre>
			</td>
		</tr>
		<tr>
			<td>срез строки</td>
			<td>
				<pre><code>const str = 'stringify';
console.log(str.slice(0, 5)); // 'strin'
console.log(str.slice(-4, -1)); // 'gif'</code></pre>
			</td>
		</tr>
		<tr>
			<td>сравнение</td>
			<td>
				<pre><code>console.log('a' > 'Z'); // true (коды символов)
console.log('Строка' === 'строка'); // false
console.log('Привет'.localeCompare('Пока')); // 1</code></pre>
			</td>
		</tr>
	</table>

	<h2>Массивы</h2>
	<table>
		<tr>
			<td>создание массива</td>
			<td>
				<pre><code>const arr1 = [1, 2, 3];
const arr2 = new Array(1, 2, 3);
const arr3 = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']</code></pre>
			</td>
		</tr>
		<tr>
			<td>обращение к элементам</td>
			<td>
				<pre><code>const fruits = ['Яблоко', 'Апельсин', 'Груша'];
console.log(fruits[0]); // 'Яблоко'
fruits[2] = 'Груша'; // изменение элемента</code></pre>
			</td>
		</tr>
		<tr>
			<td>длина</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
console.log(arr.length); // 3
arr.length = 2; // укорачиваем массив
console.log(arr); // [1, 2]</code></pre>
			</td>
		</tr>
		<tr>
			<td>последние элементы</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
console.log(arr.at(-1)); // 3 (последний элемент)
console.log(arr[arr.length - 1]); // 3 (альтернатива)</code></pre>
			</td>
		</tr>
		<tr>
			<td>получение последнего, добавление последнего, получение первого, добавление первого</td>
			<td>
				<pre><code>const arr = [1, 2];
arr.push(3); // [1, 2, 3] (добавить в конец)
arr.pop(); // [1, 2] (удалить последний)
arr.unshift(0); // [0, 1, 2] (добавить в начало)
arr.shift(); // [1, 2] (удалить первый)</code></pre>
			</td>
		</tr>
		<tr>
			<td>перебор</td>
			<td>
				<pre><code>const arr = ['Яблоко', 'Апельсин', 'Груша'];

// for..of
for (const fruit of arr) {
  console.log(fruit);
}

// forEach
arr.forEach((item, index, array) => {
  console.log(`${index}: ${item}`);
});</code></pre>
			</td>
		</tr>
		<tr>
			<td>многомерные</td>
			<td>
				<pre><code>const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
console.log(matrix[1][1]); // 5</code></pre>
			</td>
		</tr>
		<tr>
			<td>перевод в строку</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
console.log(arr.toString()); // "1,2,3"
console.log(arr.join('; ')); // "1; 2; 3"</code></pre>
			</td>
		</tr>
		<tr>
			<td>сравнение по ссылке</td>
			<td>
				<pre><code>const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];
console.log(arr1 == arr2); // false (разные объекты)
console.log(JSON.stringify(arr1) === JSON.stringify(arr2)); // true</code></pre>
			</td>
		</tr>
		<tr>
			<td>вырезание</td>
			<td>
				<pre><code>const arr = ['Я', 'изучаю', 'JavaScript'];
const removed = arr.splice(1, 1); // ['изучаю']
console.log(arr); // ['Я', 'JavaScript']

const sliced = arr.slice(0, 1); // ['Я'] (не изменяет исходный массив)</code></pre>
			</td>
		</tr>
		<tr>
			<td>объединение</td>
			<td>
				<pre><code>const arr1 = [1, 2];
const arr2 = [3, 4];
console.log(arr1.concat(arr2)); // [1, 2, 3, 4]
console.log([...arr1, ...arr2]); // [1, 2, 3, 4] (spread оператор)</code></pre>
			</td>
		</tr>
		<tr>
			<td>перебор</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
const newArr = arr.map(item => item * 2);
console.log(newArr); // [2, 4, 6]</code></pre>
			</td>
		</tr>
		<tr>
			<td>поиск</td>
			<td>
				<pre><code>const users = [
  {id: 1, name: 'Вася'},
  {id: 2, name: 'Петя'}
];

const user = users.find(item => item.id == 1);
console.log(user.name); // 'Вася'

console.log(users.findIndex(item => item.id == 2)); // 1</code></pre>
			</td>
		</tr>
		<tr>
			<td>фильтр</td>
			<td>
				<pre><code>const users = [
  {id: 1, name: 'Вася'},
  {id: 2, name: 'Петя'}
];

const filtered = users.filter(item => item.id < 2);
console.log(filtered.length); // 1</code></pre>
			</td>
		</tr>
		<tr>
			<td>преобразование</td>
			<td>
				<pre><code>const lengths = ['Бильбо', 'Гэндальф'].map(item => item.length);
console.log(lengths); // [6, 8]

const numbers = ['1', '2', '3'].map(Number);
console.log(numbers); // [1, 2, 3]</code></pre>
			</td>
		</tr>
		<tr>
			<td>сортировка</td>
			<td>
				<pre><code>const arr = [1, 2, 15];
arr.sort(); // [1, 15, 2] (по умолчанию как строки)
arr.sort((a, b) => a - b); // [1, 2, 15] (правильная сортировка чисел)</code></pre>
			</td>
		</tr>
		<tr>
			<td>разворот</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
console.log(arr.reverse()); // [3, 2, 1]</code></pre>
			</td>
		</tr>
		<tr>
			<td>работа со всеми элементами</td>
			<td>
				<pre><code>const arr = [1, 2, 3];
console.log(arr.every(item => item > 0)); // true
console.log(arr.some(item => item > 2)); // true
console.log(arr.reduce((sum, item) => sum + item, 0)); // 6</code></pre>
			</td>
		</tr>
		<tr>
			<td>проверка на массив</td>
			<td>
				<pre><code>console.log(Array.isArray([])); // true
console.log(Array.isArray({})); // false</code></pre>
			</td>
		</tr>
		<tr>
			<td>деструктуризация</td>
			<td>
				<pre><code>const arr = ['Иван', 'Иванов'];
const [firstName, surname] = arr;
console.log(firstName); // 'Иван'

// Пропуск элементов
const [first, , third] = ['первый', 'второй', 'третий'];</code></pre>
			</td>
		</tr>
		<tr>
			<td>оператор расширения</td>
			<td>
				<pre><code>const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4]

function sum(a, b, c) { return a + b + c; }
console.log(sum(...[1, 2, 3])); // 6</code></pre>
			</td>
		</tr>
	</table>

	<h2>map</h2>
	<table>
		<tr>
			<td>Если нужно быстро искать что-то по ключу или хранить связанные данные</td>
			<td>const userMap = new Map();userMap.set('user1', {name: 'Ivan', age: 30});</td>
		</tr>
	</table>

	<h2>set</h2>
	<table>
		<tr>
			<td>Если нужно просто собрать уникальные элементы</td>
			<td>const tags = new Set();tags.add('javascript');tags.add('programming');</td>
		</tr>
	</table>

	<h2>WeakMap</h2>
	<table>
		<tr>
			<td>ключи в WeakMap должны быть объектами (не примитивами). если на объект больше нет ссылок, он может быть автоматически удалён сборщиком мусора. Когда нужно связать данные с объектом, и при этом важно, чтобы эти данные исчезли, когда объект больше не нужен.</td>
			<td>const wm = new WeakMap();const obj = {};wm.set(obj, 'some data');</td>
		</tr>
	</table>

	<h2>WeakSet</h2>
	<table>
		<tr>
			<td>Это похожий на Set, который хранит только объекты.
Также не "держит" объекты в памяти — если на объект больше нет ссылок, он может быть удалён сборщиком мусора. В отличие от обычного Set, в WeakSet нельзя перебирать элементы или получать их список</td>
			<td>const ws = new WeakSet();const obj = {};ws.add(obj);</td>
		</tr>
	</table>

	<h2>Дата и время</h2>
	<table>
		<tr>
			<td>Отображение текущей даты и времени</td>
			<td>Запись времени событий</td>
		</tr>
	</table>

	<h2></h2>
	<table>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</table>

	<h2></h2>
	<table>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</table>

	<h2></h2>
	<table>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</table>

	<h2></h2>
	<table>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</table>

</body>

</html>
